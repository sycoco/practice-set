'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _credentials = require('../credentials');

var _metadata = require('./metadata');

var _tokenRefreshInterceptor = require('./token-refresh-interceptor');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /**
                                                                                                                                                                                                                   * @author qix
                                                                                                                                                                                                                   * @homepage https://github.com/qixman/
                                                                                                                                                                                                                   * @since 2016-10-11
                                                                                                                                                                                                                   */


var needToRefreshToken = false;

exports.default = {

	beforeSend: function beforeSend(xhr, config) {

		var credential = (0, _credentials.getRequestCredential)();
		var accessToken = _metadata.CREDENTIAL_KEY_MAPPER.accessToken,
		    refreshToken = _metadata.CREDENTIAL_KEY_MAPPER.refreshToken,
		    expireTime = _metadata.CREDENTIAL_KEY_MAPPER.expireTime;

		if (!credential) {
			(0, _tokenRefreshInterceptor.execAuthFailure)(xhr);
			return;
		}

		xhr.setRequestHeader(_metadata.REQUEST_TOKEN_HEADER, (0, _metadata.REQUEST_TOKEN_VALUE)(credential[accessToken]));
		xhr[_metadata.REQUEST_TOKEN_HEADER] = (0, _metadata.REQUEST_TOKEN_VALUE)(credential[accessToken]);
		if (credential[refreshToken] && _metadata.REQUEST_WHITE_LIST.indexOf(config.url) === -1) {

			// expireTime type is second
			var expireDateTime = credential[expireTime] * 1000;
			var now = _metadata.Date.now();

			// token失效则直接跳转登录页面
			// token未失效但是可用时长已低于用户会话最短保留时间,则需要刷新token
			if (_metadata.USER_SESSION_AVAILABLE_TIME >= expireDateTime - now && expireDateTime - now >= 0) {
				needToRefreshToken = true;
			} else if (expireDateTime - now < 0) {
				// token失效
				(0, _tokenRefreshInterceptor.execAuthFailure)(xhr);
			}
		}
	},
	complete: function complete(xhr) {

		// 如果请求能正常响应,说明 storage 里的状态是存在的,所以这里不做判断
		var credential = (0, _credentials.getRequestCredential)();
		var accessToken = _metadata.CREDENTIAL_KEY_MAPPER.accessToken,
		    refreshToken = _metadata.CREDENTIAL_KEY_MAPPER.refreshToken;

		var $ = window.$;

		// 所有请求结束了才做refreshToken的操作,避免后端因为token被刷新而导致前一请求失败
		if (needToRefreshToken && $.active <= 1) {
			needToRefreshToken = false;
			// refresh token
			$.ajax({
				url: _tokenRefreshInterceptor.refreshTokenUrl,
				type: 'POST',
				data: {
					refresh_token: credential[refreshToken],
					grant_type: 'refresh_token'
				},
				headers: _defineProperty({
					'Content-Type': 'application/x-www-form-urlencoded'
				}, _metadata.REQUEST_TOKEN_HEADER, (0, _metadata.REQUEST_TOKEN_VALUE)(credential[accessToken]))
			}).done(function (response) {
				// 更新localStorage中token信息
				(0, _credentials.setRequestCredential)(response);
			}).fail(function () {
				return (0, _tokenRefreshInterceptor.execAuthFailure)(xhr);
			});
		}
	}
};